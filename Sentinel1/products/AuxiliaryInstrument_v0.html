<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html>

<head>
<title>AuxiliaryInstrument v0</title>
<link rel="stylesheet" href="../../codadef.css" type="text/css" />
</head>

<body>
<h1>AuxiliaryInstrument version 0</h1>
<h2>AuxiliaryInstrument_v0</h2>
<p>This definition is based on version 2.9/2.10 of the Sentinel-1 IPF Auxiliary Product Specification S1-RS-MDA-52-7443</p>
<h3>root type</h3>
<table class="top">
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Instrument auxiliary file definition (AUX_INS).  This file includes information related to the instrument required for processing.  It is required for data decompression and ISP decoding.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>auxiliaryInstrument</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>schemaVersion</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
<br />
<span class="attr_key">available</span><span class="attr_value">: optional</span>
</span>
</td></tr>
</table>
<br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>noNamespaceSchemaLocation</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
<br />
<span class="attr_key">available</span><span class="attr_value">: optional</span>
</span>
</td></tr>
</table>
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>radarFrequency</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
Radar frequency.
<br /><br />
<span class="attr_key">unit</span><span class="attr_value">: "Hz"</span>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>deltaTGuard1</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
DeltaT Guard 1 parameter from the instrument radar database [s]. This parameter is used to calculate the internal time delay of the extracted reconstructed replicas.
<br /><br />
<span class="attr_key">unit</span><span class="attr_value">: "s"</span>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>2</td><td><b>deltaTSuppr</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
DeltaT Suppr parameter from the SSPPDU document [s]. This parameter is used to calculate the times within the PRI for the echo, calibration and noise data.
<br /><br />
<span class="attr_key">unit</span><span class="attr_value">: "s"</span>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>3</td><td><b>rollSteeringParams</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
List of calibration parameter records.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>referenceAntennaAngle</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
Antenna bore sight off nadir angle at the referenceHeight.
<br /><br />
<span class="attr_key">unit</span><span class="attr_value">: "degrees"</span>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>referenceHeight</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
Satellite height at which the instrument elevation angle is aligned with the referenceAntennaAngle.
<br /><br />
<span class="attr_key">unit</span><span class="attr_value">: "m"</span>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>2</td><td><b>rollSteeringSensitivity</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
Sensitivity of the roll steering versus height.
<br /><br />
<span class="attr_key">unit</span><span class="attr_value">: "degrees/m"</span>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>4</td><td><b>swathParamsList</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
List of calibration parameter records.
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>swathParams</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
<span class="attr_key">dim_0</span><span class="attr_value">: determined automatically from xml file</span>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Calibration parameter record. There must be one record per swath (16 nominal swaths) per polarisation (4 polarisation combinations for SM, IW or EW, 2 for WV) for a minimum total of 58. There are 128 possible swath number values supported by the downlink, so the maximum number of combinations of swath number and polarisation that can be defined is 512.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>swath</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
Canonical name of the swath for this swathNumber.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>radarParams</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Radar parameters record.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>azimuthSteeringRate</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
TOPSAR azimuth steering rate. This field is only relevant for IW and EW swaths and is set to 0.0 for SM and WV swaths.
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>2</td><td><b>pulseParams</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Replica pulse parameters. This DSR contains the characteristics for the nominal imaging replica pulse within this swath.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>amplitudeCoefficients</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
Pulse amplitude coefficients of the nominal imaging chirp replica.
<br /><br />
<span class="attr_key">dim_0</span><span class="attr_value">: <b>int</b>(<b>str</b>(@count))</span>
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">ascii&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;float</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>phaseCoefficients</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
Pulse phase coefficients of the nominal imaging chirp replica.
<br /><br />
<span class="attr_key">dim_0</span><span class="attr_value">: <b>int</b>(<b>str</b>(@count))</span>
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">ascii&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;float</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>2</td><td><b>nominalTxPulseLength</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
Nominal transmit pulse length [s]. This parameter is used by the pre-processor and the DCE and SLC processors if it is smaller than the Tx Pulse Length (TXPL) extracted from the ISP headers. The nominal transmit pulse length can be set such that the chirp processed bandwidth is small enough to filter out the spurious signals at ±37.5 MHz.
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>3</td><td><b>rxVariationCorrectionParamsList</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>rxVariationCorrectionParams</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
<span class="attr_key">dim_0</span><span class="attr_value">: determined automatically from xml file</span>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>rxPolarisation</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
Polarisation to which this set of receive correction parameters applies. "H" or "V".
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>gainTrendCoefficients</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
Gain trend correction coefficients.
<br /><br />
<span class="attr_key">dim_0</span><span class="attr_value">: <b>int</b>(<b>str</b>(@count))</span>
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">ascii&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;float</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>2</td><td><b>gainOvershootCoefficients</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
Gain overshoot correction coefficients.
<br /><br />
<span class="attr_key">dim_0</span><span class="attr_value">: <b>int</b>(<b>str</b>(@count))</span>
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">ascii&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;float</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>5</td><td><b>internalCalibrationParamsList</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Internal calibration instrument parameters. This record contains swath/polarisation channel dependent parameters related to the instrument. There must be one record per swath (16 nominal swaths) per polarisation (4 polarisation combinations for SM, IW or EW, 2 for WV) for a minimum total of 60. There are 128 possible swath number values supported by the downlink, so the maximum number of combinations of swath number and polarisation that can be defined is 512.
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>internalCalibrationParams</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
<span class="attr_key">dim_0</span><span class="attr_value">: determined automatically from xml file</span>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Internal calibration instrument parameters. This record contains swath/polarisation channel dependent parameters related to the instrument. There must be one record per swath (16 nominal swaths) per polarisation (4 polarisation combinations for SM, IW or EW, 2 for WV) for a minimum total of 58. There are 128 possible swath number values supported by the downlink, so the maximum number of combinations of swath number and polarisation that can be defined is 512.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>swath</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
Canonical name of the swath.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>polarisation</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
Polarisation. Used along with the swathNumber to index the applicable internalCalibrationParams record.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>2</td><td><b>timeDelay</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
Internal time delay [s] to be applied to the reference chirp used for range processing. The IPF only uses this parameter when the time delay cannot be derived from the extracted PG replicas due to invalid (poor quality) reconstructed PG replicas. Nominally, the time delay is estimated as the average internal time delay from the all of the extracted PG replicas and it compensates for the dual polarisation mis-registration.
<br /><br />
<span class="attr_key">unit</span><span class="attr_value">: "s"</span>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>3</td><td><b>nominalGain</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Complex gain to be applied to the range match filter when the nominal chirp is used. It is used to compensate for the amplitude and phase differences between the two channels in dual polarisation data.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>re</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>im</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>4</td><td><b>extractedGain</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Complex gain to be applied to the range match filter when the extracted replica is used. It is used to compensate for the amplitude difference between the two channels in dual polarisation data. Phase difference compensation is not done when the extracted replica is used since the phase difference is already embedded in the extracted replicas.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>re</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>im</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>5</td><td><b>pgProductModel</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Modeled PG product.  The model is relative to the ascending node of the current orbit.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>pgModelInterval</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
Interval between adjacent PG Product values in the list.
<br /><br />
<span class="attr_key">unit</span><span class="attr_value">: "s"</span>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>values</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
Array of modeled complex PG model values.  The pattern contains attribute "count" complex floating point values separated by spaces.  The first value in the array corresponds to the time at the ascending node of the current orbit.
<br /><br />
<span class="attr_key">dim_0</span><span class="attr_value">: <b>int</b>(<b>str</b>(@count))</span>
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">ascii&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;complex</th></tr>
<tr valign="top">
<td colspan="2">
<blockquote>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>real</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;float</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>imaginary</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;float</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>6</td><td><b>pgReference</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Reference absolute PG value that will be defined by offline analysis of the acquired data.  PG values used by the IPF will be normalised by this PG reference value.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>re</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>im</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>7</td><td><b>swstBias</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
SWST bias.
<br /><br />
<span class="attr_key">unit</span><span class="attr_value">: "s"</span>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>8</td><td><b>noise</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
Nominal noise value if noise used in processing if no noise value can be calculated from the downlink.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>9</td><td><b>replicaPccParamsList</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
List of PCC decoding control parameters for the extracted replicas at nominal imaging bandwidth.
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>pccParams</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
<span class="attr_key">dim_0</span><span class="attr_value">: determined automatically from xml file</span>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
PCC decoding parameters for controlling the order and way in which calibration pulses are decoded during processing. There are a minimum of 5 entries in the list, one for each nominal calibration pulse, and a maximum of 6 entries in the list for the transmit H polarisation which includes an additional isolation pulse.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>signal</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
Signal type.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>order</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
PCC pulse selection order. This is a list of integers separated by spaces that defines the order in which the pulses are combined using the method below.
<br /><br />
<span class="attr_key">dim_0</span><span class="attr_value">: <b>int</b>(<b>str</b>(@count))</span>
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">ascii&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;int32</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>2</td><td><b>method</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
Method to use to combine the calibration pulses selected by the order above. The PCC2 method subtracts the pulses in order and averages over the number of pulses. The Average method adds the pulses in order and averages over the number of pulses. The Isolation Subtraction method finds the PCC parameters record for the corresponding isolation pulse and subtracts the selected isolation pulse from the selected nominal pulse.
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>10</td><td><b>pgPccParamsList</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
List of PCC decoding control parameters for the PG replicas at 100 MHz bandwidth
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>pccParams</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
<span class="attr_key">dim_0</span><span class="attr_value">: determined automatically from xml file</span>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
PCC decoding parameters for controlling the order and way in which calibration pulses are decoded during processing. There are a minimum of 5 entries in the list, one for each nominal calibration pulse, and a maximum of 6 entries in the list for the transmit H polarisation which includes an additional isolation pulse.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>signal</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
Signal type.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>order</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
PCC pulse selection order. This is a list of integers separated by spaces that defines the order in which the pulses are combined using the method below.
<br /><br />
<span class="attr_key">dim_0</span><span class="attr_value">: <b>int</b>(<b>str</b>(@count))</span>
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">ascii&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;int32</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>2</td><td><b>method</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
Method to use to combine the calibration pulses selected by the order above. The PCC2 method subtracts the pulses in order and averages over the number of pulses. The Average method adds the pulses in order and averages over the number of pulses. The Isolation Subtraction method finds the PCC parameters record for the corresponding isolation pulse and subtracts the selected isolation pulse from the selected nominal pulse.
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>6</td><td><b>timelineList</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Timeline list. This element contains a list of records that describe the expected packet transmission sequence for each of the Sentinel-1 SAR modes. The SPPDU document allows for 48 entries numbered from 0-47. At minimum, this list must include 9 entries: an entry for each instrument measurement mode.
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>timeline</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
<span class="attr_key">dim_0</span><span class="attr_value">: determined automatically from xml file</span>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Each timeline element describes the expected packet transmission sequence for one of the operational modes of the satellite.  The SPPDU [A-12] allows for 48 entries numbered from 0-47. At minimum, this list must include 10 entries: an entry for each instrument measurement mode (S1, S2, S3, S4, S5-N, S5-S, S6, IW, EW and WV).
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>eccNumber</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;int64</th></tr>
<tr valign="top">
<td colspan="2">
Event Control Code (ECC) number. This field uniquely identifies the ECC program number for this instrument mode and is used by the IPF for timeline selection.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>mode</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
Instrument mode. This field identifies the instrument mode to which this timeline entry applies.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>2</td><td><b>sequenceList</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Sequence list. This element is a list of activity sequences that together form the expected transmission sequence from the SAR instrument for the data take. The number of sequences is arbitrary but there are 5 slots nominally allocated for 1- an initial noise measurement; 2- an initial calibration sequence; 3- image acquisition; 4- final calibration sequence; and, 5- final noise measurement.
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>sequence</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
<span class="attr_key">dim_0</span><span class="attr_value">: determined automatically from xml file</span>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Calibration parameter record. There must be one record per swath (16 nominal swaths) per polarisation (4 polarisation combinations for SM, IW or EW, 2 for WV) for a minimum total of 58. There are 128 possible swath number values supported by the downlink, so the maximum number of combinations of swath number and polarisation that can be defined is 512.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>name</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
The name of the activity within the data acquisition to which this sequence belongs. This field is not used by the IPF for processing. It is for informative purposes only and so the range of the field is unbounded.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>repeat</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;uint8</th></tr>
<tr valign="top">
<td colspan="2">
Sequence repeat flag. For the imaging sequence, this field shall be set to “true” to indentify the ispList that represents the imaging operation. This field shall be set to “false” for all other sequences.
<br /><br />
<span class="attr_key">mapping</span><span class="attr_value">: "false"&nbsp;-&gt;&nbsp;0</span>
<br /><br />
<span class="attr_key">mapping</span><span class="attr_value">: "true"&nbsp;-&gt;&nbsp;1</span>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>2</td><td><b>ispList</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
ISP list. This element contains contains a list of the expected packets within this sequence in the order they should be received. The number of ISP entries is arbitrary but there are 30 slots defined to capture the worst case EW echo acquisition with PCC2 sequences at the end of each burst.
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>isp</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
<span class="attr_key">dim_0</span><span class="attr_value">: determined automatically from xml file</span>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
The ISP element describes one unique, or a series of unique transmission packets. The packets are identified by the packet signal type and contain the number of PRIs expected for this packet type.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>swath</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
Canonical name of the swath to which this packet belongs.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>signal</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
Signal type.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>2</td><td><b>bandwidth</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
Signal bandwidth type.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>3</td><td><b>numPri</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;uint32</th></tr>
<tr valign="top">
<td colspan="2">
The number of packets of this signal type expected in series.
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>3</td><td><b>swathMapList</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Swath mapping list. This element is a list of the swaths applicable to this ECC program and provides a mapping between the swath number fields in the source packet headers and the logical instrument swath name to which they apply.
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>swathMap</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
<span class="attr_key">dim_0</span><span class="attr_value">: determined automatically from xml file</span>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Calibration parameter record. There must be one record per swath (16 nominal swaths) per polarisation (4 polarisation combinations for SM, IW or EW, 2 for WV) for a minimum total of 58. There are 128 possible swath number values supported by the downlink, so the maximum number of combinations of swath number and polarisation that can be defined is 512.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>swathNumber</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;int64</th></tr>
<tr valign="top">
<td colspan="2">
The swath number from the source packet secondary header to map to a particular logical swath within the instrument mode.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>swath</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
Canonical name of the swath to which this packet belongs.
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>7</td><td><b>decodingParams</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Raw data decoding parameters. This DSR contains the raw data decoding tables and parameters that the IPF requires to perform image processing.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>huffmanLutList</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Huffman decoding LUT list. This element contains the Huffman decoding LUTs required to retrieve the HCode value from FDBAQ encoded user data.  There is one LUT for each Bit Rate Code for a total of 5.
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>huffmanLut</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
<span class="attr_key">dim_0</span><span class="attr_value">: determined automatically from xml file</span>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Huffman decoding LUT. This element contains the Huffman binary tree values for the applicable Bit Rate Code. The MCode is recovered by applying the values in the decoding LUT to the extracted HCode.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>baqCode</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
Bit Rate Code (as extracted from the BAQ block) to which this LUT applies.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>values</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
Huffman binary decoding tree values. The tree is implemented using a simple binary coding in which starting at the root, the left side is defined and then the right side is defined. Each node is identified by a 0 followed by a 0 or 1 representing the value of the node. Each leaf is identified by a 1 followed by a 0 or 1 representing the value of the leaf followed by 4 bits representing the MCode value. This encoding scheme is a proposal and will be confirmed prior to CDR.
<br /><br />
<span class="attr_key">dim_0</span><span class="attr_value">: <b>int</b>(<b>str</b>(@count))</span>
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">ascii&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;int32</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>nrlLutList</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Normalised Reconstruction Levels LUT list. This element contains the NRL LUTs required to retrieve the normalised reconstructed sample values from the BAQ encoded data. There is one LUT per BAQ mode/FDBAQ Bit Rate Code for a total of 8 LUTs.
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>rlLut</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
<span class="attr_key">dim_0</span><span class="attr_value">: determined automatically from xml file</span>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Reconstruction Levels LUT. This LUT contains the RL values used to retrieve the reconstructed sample values from the BAQ encoded data. The RL in the table are indexed by: 1. the Bit Rate Code extracted from the BAQ data block for FDBAQ compression; and,  2. the BAQ mode (3-bit, 4-bit or 5-bit) for BAQ compression.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>baqCode</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
Index code for which the LUT applies. For FDBAQ compression this is the Bit Rate Code extracted from the BAQ block and for BAQ compression this is the BAQ mode.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>values</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
NRL LUT values. This element contains fifteen double precision floating point values separated by spaces, one entry for each MCode value. Note that some MCodes are not applicable for some FDBAQ and BAQ modes so in this case the entry shall be "NaN" to signify an invalid index.
<br /><br />
<span class="attr_key">dim_0</span><span class="attr_value">: <b>int</b>(<b>str</b>(@count))</span>
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">ascii&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>2</td><td><b>srlLutList</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Simple Reconstruction Parameters LUT list. This element contains the Simple Reconstruction Parameters LUTs required to retrieve the simple reconstructed sample values from the BAQ encoded data. There is one LUT per BAQ mode/FDBAQ Bit Rate Code for a total of 8 LUTs.
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>rlLut</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
<span class="attr_key">dim_0</span><span class="attr_value">: determined automatically from xml file</span>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Reconstruction Levels LUT. This LUT contains the RL values used to retrieve the reconstructed sample values from the BAQ encoded data. The RL in the table are indexed by: 1. the Bit Rate Code extracted from the BAQ data block for FDBAQ compression; and,  2. the BAQ mode (3-bit, 4-bit or 5-bit) for BAQ compression.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>baqCode</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
Index code for which the LUT applies. For FDBAQ compression this is the Bit Rate Code extracted from the BAQ block and for BAQ compression this is the BAQ mode.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>values</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
NRL LUT values. This element contains fifteen double precision floating point values separated by spaces, one entry for each MCode value. Note that some MCodes are not applicable for some FDBAQ and BAQ modes so in this case the entry shall be "NaN" to signify an invalid index.
<br /><br />
<span class="attr_key">dim_0</span><span class="attr_value">: <b>int</b>(<b>str</b>(@count))</span>
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">ascii&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;double</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>3</td><td><b>sigmaFactorLut</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
Sigma Factors LUT. This LUT contains the values used to upscale the normalised reconstructed samples. The sigma factors in the table are indexed by the Threshold Index (THIDX) extracted from the BAQ block. This vector contains 255 single precision floating point numbers separated by spaces.
<br /><br />
<span class="attr_key">dim_0</span><span class="attr_value">: <b>int</b>(<b>str</b>(@count))</span>
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">ascii&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;float</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>4</td><td><b>thresholdLutList</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Raw data decoding control LUT list. This element contains the parameters required to decode the BAQ and FDBAQ encoded data.
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>thresholdLut</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
<span class="attr_key">dim_0</span><span class="attr_value">: determined automatically from xml file</span>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;record</th></tr>
<tr valign="top">
<td colspan="2">
Threshold LUT containing the thresholds needed to decode the BAQ and FDBAQ encoded data. There is one record for each of the BAQ-modes/FDBAQ-BRCs for a total of 8.
<br /><br />
<table class="fancy" border="1" cellspacing="0" width="100%">
<tr><th class="subhdr">id</th><th class="subhdr">field&nbsp;name</th><th class="subhdr">definition</th></tr>
<tr valign="top"><td>0</td><td><b>baqCode</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">xml&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
BAQ-mode/FDBAQ-BRC to which this set of thresholds applies.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>1</td><td><b>thidxThreshold</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;int32</th></tr>
<tr valign="top">
<td colspan="2">
THIDX threshold used to determine whether to use the simple reconstruction method or the normal reconstruction method. If the THIDX extracted from the data is less than or equal to this threshold, then the simple reconstruction method is used; otherwise, the normal reconstruction method is used.
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>2</td><td><b>mCodeThreshold</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;int32</th></tr>
<tr valign="top">
<td colspan="2">
Mcode threshold used in simple reconstruction to determine whether to use the extracted Mcode or the the simple reconstruction LUT. If the Mcode extracted from the data is less than this threshold, then the extracted Mcode is used; otherwise, the simple reconstruction LUT is used.
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>5</td><td><b>tguLut</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
TGU temperature LUT. This LUT contains the values that are used to convert the TGU temperature codes extracted from the sub-commutated ancillary data in the ISP headers into the correct temperature value [degrees C]. The LUT contains a list of 128 single-precision floating values separated by spaces with the index of each entry, numbered 0 .. 127, corresponding to the code for which the temperature value applies. The index of each entry represents the code to convert, with the first entry in the list starting at index/code 0 and incrementing by 1 for each subsequent entry.
<br /><br />
<span class="attr_key">dim_0</span><span class="attr_value">: <b>int</b>(<b>str</b>(@count))</span>
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">ascii&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;float</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
<tr valign="top"><td>6</td><td><b>tileLut</b></td>
<td>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;array[<i><b>dim_0</b></i>]</th></tr>
<tr valign="top">
<td colspan="2">
Tile temperature LUT. This LUT contains the values that are used to convert the EFE and active TA temperature codes extracted from the sub-commutated ancillary data in the ISP headers into the correct temperature value [degrees C]. The LUT contains a list of 256 single-precision floating values separated by spaces with the index of each entry, numbered 0 .. 255, corresponding to the code for which the temperature value applies. The index of each entry represents the code to convert, with the first entry in the list starting at index/code 0 and incrementing by 1 for each subsequent entry.
<br /><br />
<span class="attr_key">dim_0</span><span class="attr_value">: <b>int</b>(<b>str</b>(@count))</span>
<br /><br />
<table style="border-style: none" cellspacing="0" width="100%">
<tr valign="top"><td style="border-style: none"><span class="attr_key">attribute</span><span class="attr_value">: <b>count</b></td><td style="border-width: 2px"><table>
<tr><th  colspan="2"align="left">ascii&nbsp;string</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</span>
</td></tr>
</table>
<br />
<blockquote>
<table>
<tr><th  colspan="2"align="left">ascii&nbsp;float</th></tr>
<tr valign="top">
<td colspan="2">
</td>
</tr>
</table>
</blockquote>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
<h3>detection rule</h3>
<p>This product definition is applicable if a product matches the following rule:</p>
<table class="fancy" border="1" cellspacing="0" width="600px">  <tr>
    <td>
<b>exists</b>(/auxiliaryInstrument)
    </tr>
  </td>
</table>
</body>

</html>
